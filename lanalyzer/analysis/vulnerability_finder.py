"""
Vulnerability finder module for enhanced taint analysis.
"""

from typing import Any, Dict, List

from lanalyzer.analysis.visitor import EnhancedTaintAnalysisVisitor


class VulnerabilityFinder:
    """
    Finds vulnerabilities by analyzing taint propagation.
    """

    def __init__(self, tracker):
        """
        Initialize the vulnerability finder.

        Args:
            tracker: The parent tracker instance
        """
        self.tracker = tracker
        self.debug = tracker.debug
        self.config = tracker.config

    def find_vulnerabilities(
        self, visitor: EnhancedTaintAnalysisVisitor, file_path: str
    ) -> List[Dict[str, Any]]:
        """
        Find vulnerabilities using enhanced tracking information.

        Args:
            visitor: EnhancedTaintAnalysisVisitor instance
            file_path: Path to the analyzed file

        Returns:
            List of enhanced vulnerability dictionaries
        """
        vulnerabilities = []

        for sink in visitor.found_sinks:
            for tainted_arg in sink.get("tainted_args", []):
                arg_name, source_info = tainted_arg

                # Find matching rule
                for rule in self.config.get("rules", []):
                    source_name = source_info["name"]
                    sink_name = sink["name"]

                    if self._source_matches_rule(
                        source_name, rule
                    ) and self._sink_matches_rule(sink_name, rule):
                        # Get taint propagation chain for this vulnerability
                        propagation_chain = self._build_propagation_chain(
                            visitor, sink, arg_name, source_info
                        )

                        # Get detailed call chain
                        call_chain = (
                            self.tracker.call_chain_builder.get_detailed_call_chain(
                                sink, visitor, source_info
                            )
                        )

                        # Format message with the actual source name
                        message = rule.get(
                            "message",
                            f"Tainted data from {source_name} flows to {sink_name}",
                        )
                        message = message.replace("{source}", source_name)
                        message = message.replace("{sink}", sink_name)

                        # Add a final step in the propagation chain showing sink usage
                        if propagation_chain:
                            propagation_chain.append(
                                {
                                    "step_no": len(propagation_chain) + 1,
                                    "operation": "SinkUsage",
                                    "description": f"Tainted data flows to {sink_name} sink at line {sink.get('line', 0)}",
                                    "line": sink.get("line", 0),
                                    "var_name": arg_name,
                                }
                            )

                        # Build enhanced vulnerability info
                        vulnerability = {
                            "rule": rule.get("name", "UnnamedRule"),
                            "message": message,
                            "file": file_path,
                            "source": {
                                "name": source_name,
                                "line": source_info.get("line", 0),
                                "col": source_info.get("col", 0),
                            },
                            "sink": {
                                "name": sink_name,
                                "line": sink.get("line", 0),
                                "col": sink.get("col", 0),
                            },
                            "tainted_variable": arg_name,
                            "propagation_chain": propagation_chain,
                            "call_chain": call_chain,
                        }

                        vulnerabilities.append(vulnerability)

        return vulnerabilities

    def _source_matches_rule(self, source_name: str, rule: Dict[str, Any]) -> bool:
        """
        Check if a source matches a rule.

        Args:
            source_name: Name of the source
            rule: Rule dictionary

        Returns:
            True if the source matches the rule, False otherwise
        """
        sources = rule.get("sources", [])
        return source_name in sources or "any" in sources

    def _sink_matches_rule(self, sink_name: str, rule: Dict[str, Any]) -> bool:
        """
        Check if a sink matches a rule.

        Args:
            sink_name: Name of the sink
            rule: Rule dictionary

        Returns:
            True if the sink matches the rule, False otherwise
        """
        sinks = rule.get("sinks", [])
        return sink_name in sinks or "any" in sinks

    def _build_propagation_chain(
        self,
        visitor: EnhancedTaintAnalysisVisitor,
        sink: Dict[str, Any],
        arg_name: str,
        source_info: Dict[str, Any],
    ) -> List[Dict[str, Any]]:
        """
        Build the propagation chain showing taint flow.

        Args:
            visitor: EnhancedTaintAnalysisVisitor instance
            sink: Sink dictionary
            arg_name: Argument name
            source_info: Source information dictionary

        Returns:
            List of propagation chain steps
        """
        propagation_chain = []

        if isinstance(arg_name, str):
            # Handle direct call arguments
            if arg_name.startswith("direct_call_"):
                # For direct call arguments, create a basic propagation chain
                propagation_chain = [
                    {
                        "step_no": 1,
                        "operation": "DirectCall",
                        "description": f"Direct call from source to sink at line {sink.get('line', 0)}",
                        "line": sink.get("line", 0),
                        "var_name": arg_name,
                    }
                ]
            else:
                # For named arguments, get full propagation chain
                if "=" in arg_name:
                    # Handle keyword arguments
                    parts = arg_name.split("=")
                    arg_base_name = parts[0]
                    value_name = parts[1]

                    # Get chain for the value
                    if value_name in visitor.variable_taint:
                        propagation_chain = visitor.get_taint_propagation_chain(
                            value_name
                        )
                        # Add parameter binding step
                        propagation_chain.append(
                            {
                                "step_no": len(propagation_chain) + 1,
                                "operation": "ParameterBinding",
                                "description": f"Value '{value_name}' bound to parameter '{arg_base_name}' at line {sink.get('line', 0)}",
                                "line": sink.get("line", 0),
                                "var_name": arg_name,
                            }
                        )
                    # Check data structures too
                    elif value_name in visitor.data_structures:
                        ds_chain = visitor.data_structures[
                            value_name
                        ].get_propagation_chain()
                        propagation_chain.extend(ds_chain)
                        # Add parameter binding step
                        propagation_chain.append(
                            {
                                "step_no": len(propagation_chain) + 1,
                                "operation": "DataStructureBinding",
                                "description": f"Data structure '{value_name}' bound to parameter '{arg_base_name}' at line {sink.get('line', 0)}",
                                "line": sink.get("line", 0),
                                "var_name": arg_name,
                            }
                        )
                else:
                    # Regular variable
                    arg_base_name = arg_name
                    propagation_chain = visitor.get_taint_propagation_chain(
                        arg_base_name
                    )

                    # Check for data structures as well
                    if (
                        arg_base_name in visitor.data_structures
                        and not propagation_chain
                    ):
                        ds_chain = visitor.data_structures[
                            arg_base_name
                        ].get_propagation_chain()
                        propagation_chain.extend(ds_chain)

        return propagation_chain
